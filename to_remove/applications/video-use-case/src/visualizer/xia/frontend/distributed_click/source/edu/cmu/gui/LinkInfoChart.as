package edu.cmu.gui {		import flash.display.MovieClip;	import flash.display.Shape;	import flash.utils.Dictionary;	import flash.text.TextFormat;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import edu.cmu.MyGlobal;	//[Embed(source='Arial.ttf', fontName='fontArial', mimeType='application/x-font')]		public class LinkInfoChart extends LinkInfoBase {				// Constants:  TODO: make these constant		var WIDTH:int;		var HEIGHT:int;		var N:int; // how many previous points to remember		var FOREGROUND_COLOR:uint;  // color for axes and text		var PLOT_AREA_COLOR:uint;  // color for plot area rectangle		var PADDING_BOTTOM:int;  // space between X axis and bottom of box		var PADDING_LEFT:int;  // space between Y axis and left of box		var PADDING_TOP:int;		var PADDING_RIGHT:int;		var DRAW_AXES:Boolean;				//[Embed(source="/Library/Fonts/Arial Unicode.ttf", fontFamily="Arial")]		//private var _arial_str:String;		// Public Properties:		// Private Properties:		private var dataPoints:Vector.<Dictionary>;		private var localMaxRate:int;		private var effectiveMaxRate:int;		// UI Elements:		private var yMax:TextField;		private var yMid:TextField;		private var yMin:TextField;		private var linesByType:Dictionary;								// Initialization:		public function LinkInfoChart() {			dataPoints = new Vector.<Dictionary>();			linesByType = new Dictionary();			localMaxRate = 0;			effectiveMaxRate = 0;			configUI();		}		// Public Methods:		public override function updateCurrentTraffic(currentTrafficByType:Dictionary):void {			dataPoints.push(currentTrafficByType);						// See if any of the new rates is our new local or global max			for each (var rate:int in currentTrafficByType) {				if (rate > localMaxRate) {					localMaxRate = rate;				}				if (rate > MyGlobal.maxTrafficRate) {					MyGlobal.maxTrafficRate				}			}									// correct global max if our localMax is bigger than global max			// (could happen because we're not correct when we remove			// old max values from other links)			if (localMaxRate > MyGlobal.maxTrafficRate) {				MyGlobal.maxTrafficRate = localMaxRate;			}									// Remove old data points			var needNewLocalMax:Boolean = false;			var needNewGlobalMax:Boolean = false;			while (dataPoints.length > N) {				var oldRates:Dictionary = dataPoints.shift();								// See if this dictionary contains our max				// (if it did, we need to find the max in what's left)				for each (var rate:int in oldRates) {					if (rate == localMaxRate) {						needNewLocalMax = true;					}					if (rate == MyGlobal.maxTrafficRate) {						needNewGlobalMax = true;					}				}			}						// Find a new max rate if the old one just slid off the			// end of the chart			if (needNewLocalMax || needNewGlobalMax) {				if (needNewLocalMax) {					localMaxRate = 0;				}				if (needNewGlobalMax) {					// this isn't quite correct. it could be that this					// link had the old global max, but that some other					// link has the new global max; here, we're going to					// set global max to this link's new local max.					// But, the other hypothetical link with the new true					// global max will have a chance to fix the global max					// before it redraws itself, so it's okay.					MyGlobal.maxTrafficRate = 0;				}								for each (var rates:Dictionary in dataPoints) {					for each (var rate:int in rates) {						if (rate > localMaxRate) {							localMaxRate = rate;						}						if (rate > MyGlobal.maxTrafficRate) {							MyGlobal.maxTrafficRate = rate;						}					}				}			}									// pick which max to actually use for plotting			if (MyGlobal.shareMaxTrafficRate) {				effectiveMaxRate = MyGlobal.maxTrafficRate;			} else {				effectiveMaxRate = localMaxRate;			}			drawData();		}						// Protected Methods:		// Private Methods:				protected function drawData():void {			// Adjust Y axis labels			if (DRAW_AXES) {				setYAxisLabels();			}						// Remove existing lines (if any)			for each (var line:Shape in linesByType) {				if (this.contains(line)) {					this.removeChild(line);				}			}						// Make a new dictionary for new lines			linesByType = new Dictionary();						// Set up the lines			// TODO: If we later encounter a type not in the first dictionary, it will be ignored			for (var type:String in dataPoints[0]) {				var line:Shape = new Shape();				line.graphics.lineStyle(1, MyGlobal.getColorForPrincipal(type), 1);				line.graphics.moveTo(PADDING_LEFT, YCoordForValue(dataPoints[0][type]));								linesByType[type] = line;			}						// Draw lines			var xIncr:int = (WIDTH-PADDING_LEFT-PADDING_RIGHT) / N;			var x:int = PADDING_LEFT;			for each (var rates:Dictionary in dataPoints) {				for (var type:String in rates) {					linesByType[type].graphics.lineTo(x, YCoordForValue(rates[type]));				}								x += xIncr;			}						// Add lines to stage			for each (var line:Shape in linesByType) {				this.addChild(line);			}		}				protected function YCoordForValue(rate:int):int {			var yRelToXAxis:int = int(Number(rate)/Number(effectiveMaxRate)*(HEIGHT-PADDING_TOP-PADDING_BOTTOM));			return HEIGHT - PADDING_BOTTOM - yRelToXAxis;		}				protected function YMax():int {			// For now, the max Y value is the nearest number			// divisible by 10 greater than or equal to effectiveMaxRate			return (Math.ceil(effectiveMaxRate / 10)) * 10;		}				protected function setYAxisLabels():void {						// yMin is always 0, so don't worry about it						yMax.text = String(YMax());			yMax.x = PADDING_LEFT - yMax.width - 1;			yMax.y = PADDING_TOP - 2;						yMid.text = String(YMax() / 2);			yMid.x = PADDING_LEFT - yMid.width - 1;			yMid.y = yMax.y + (yMin.y - yMax.y) / 2;		}				protected override function configUI():void {			this.getChildAt(0).height = HEIGHT;			this.getChildAt(0).width = WIDTH;						// Draw X Axis			var xAxis:Shape = new Shape();			xAxis.graphics.lineStyle(2, FOREGROUND_COLOR, 1);			xAxis.graphics.moveTo(PADDING_LEFT, HEIGHT - PADDING_BOTTOM);			xAxis.graphics.lineTo(WIDTH - PADDING_RIGHT, HEIGHT - PADDING_BOTTOM);			this.addChild(xAxis);						// Label X Axis			if (DRAW_AXES) {				var xLabel:TextField = MyGlobal.makeLabel("Time", FOREGROUND_COLOR, 12, true);				xLabel.x = PADDING_LEFT + (WIDTH-PADDING_RIGHT-PADDING_LEFT-xLabel.width)/2;				xLabel.y = HEIGHT - PADDING_BOTTOM;				this.addChild(xLabel);			}						// Draw Y Axis			var yAxis:Shape = new Shape();			yAxis.graphics.lineStyle(2, FOREGROUND_COLOR, 1);			yAxis.graphics.moveTo(PADDING_LEFT, PADDING_TOP);			yAxis.graphics.lineTo(PADDING_LEFT, HEIGHT - PADDING_BOTTOM);			this.addChild(yAxis);						//// Label Y Axis			if (DRAW_AXES) {				//			var yLabel:TextField = makeEmbeddedLabel("Pkts/sec", FOREGROUND_COLOR, 12, true);	//			//yLabel.rotation = 90;	//			yLabel.x = 20;	//			yLabel.y = 40;	//			this.addChild(yLabel);								yMax = MyGlobal.makeLabel("10", FOREGROUND_COLOR);				yMax.x = PADDING_LEFT - yMax.width - 1;				yMax.y = PADDING_TOP - 2;				this.addChild(yMax);				yMin = MyGlobal.makeLabel("0", FOREGROUND_COLOR);				yMin.x = PADDING_LEFT - yMin.width - 1;				yMin.y = HEIGHT-PADDING_BOTTOM-yMin.height+2;				this.addChild(yMin);				yMid = MyGlobal.makeLabel("5", FOREGROUND_COLOR);				yMid.x = PADDING_LEFT - yMid.width - 1;				yMid.y = yMax.y + (yMin.y - yMax.y) / 2;				this.addChild(yMid);			}						// Draw background of quadrant			var bgRect:Shape = new Shape;			bgRect.graphics.beginFill(PLOT_AREA_COLOR, 0.3);			bgRect.graphics.drawRect(PADDING_LEFT, PADDING_TOP, WIDTH-PADDING_RIGHT-PADDING_LEFT, HEIGHT-PADDING_TOP-PADDING_BOTTOM); // (x spacing, y spacing, width, height)			bgRect.graphics.endFill();			this.addChild(bgRect);		}						//private function makeEmbeddedLabel(text:String, color:uint, size:uint = 11, bold:Boolean = false):TextField {//			var textFormat:TextFormat = new TextFormat(); //("ArialEmbedded", size, color); //			textFormat.font = "fontArial";//			textFormat.size = size;//			textFormat.bold = bold;//			//			var label:TextField = new TextField();			//			label.text = text;//			label.embedFonts = true;//			label.setTextFormat(textFormat);//			//label.defaultTextFormat = textFormat;//			//label.autoSize = TextFieldAutoSize.LEFT;//			//label.textColor = color;//			//			return label;//		}	}	}