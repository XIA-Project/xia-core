package edu.cmu.layouts {	import flash.display.*;	import flash.geom.Point;	import edu.cmu.topology.Topology;	import edu.cmu.networkelements.NetworkElement;		public class Layout {				// Constants:		// Public Properties:		// Private Properties:		protected var numElements:int;			// Initialization:		public function Layout() { }			// Public Methods:		public function Arrange(topology:Topology, container:DisplayObjectContainer):void {	  // TODO: Test this method!!! Looping over dict now			var lastElement:NetworkElement;					if (container == null) { trace("container is null"); return; }			if(topology.GetElementsByID() == null) { trace("elementsByID is null"); return;}			numElements = topology.GetElementsByID().length;			for each (var element:NetworkElement in topology.GetElementsByID()) {				lastElement = element;  // for invalidating the stage after we're done; a bit hacky								// If this element has already been placed, don't move it				if (element == null || container.contains(element)) { continue; }								// Add element to the stage				container.addChild(element);								// Position the element				var point:Point = this.GetPointForElement(element);				element.x = point.x;				element.y = point.y;								// Make sure element is entirely onscreen				while (element.x + element.width > element.stage.stageWidth) {					element.x -= 1;				}				while (element.y + element.height > element.stage.stageHeight) {					element.y -= 1;				}			}						if (lastElement != null) {				lastElement.stage.invalidate(); // TODO: better way to do this?			}		}				// Protected Methods:		protected function GetPointForElement(element:NetworkElement):Point {			return new Point(0, 0);		}	}	}