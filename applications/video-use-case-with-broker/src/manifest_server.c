#include <stdio.h>
#include <vector>
#include <dirent.h>
#include <stdarg.h>
#include <stdlib.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sstream>
#include <iostream>
#include <assert.h>
#include <dirent.h>
#include "manifest_server.h"

using namespace std;

/*
 ** display cmd line options and exit
 */
void help(const char *name) {
    printf("\n%s (%s)\n", TITLE, VERSION);
    printf("usage: %s\n", name);
    exit(0);
}

/*
 ** configure the app
 */
void get_config(int argc, char** argv) {
    if (argc != 1) {
        help(basename(argv[0]));
    }
}

// assuming that xhttp request string is of form:
//     xhttp://service_url/video_name
int handle_xhttp_request(int proxy_sock, char* message) {
    char reply[XIA_MAXBUF];
    memset(reply, '\0', sizeof(reply));

    // the video server only handles the initial manifest request
    // it find the manifest DAG by reading the file that contains
    // the DAG of manifest generated by the content publisher
    string msg (message);
    size_t found_begin = msg.find_last_of("/");
    size_t found_end = msg.rfind(".mpd");

    if (found_begin >= found_end) {
        return -1;
    }

    string videoName = msg.substr(found_begin + 1, found_end - found_begin - 1);
    if (videoName.size() == 0) {
        return -1;
    }
    // xia_manifest_urls_dash1.txt
    string manifestUrlName = "xia_manifest_urls_" + videoName + ".txt";

    FILE * fp;
    char * line = NULL;
    size_t len = 0;
    ssize_t read;
    vector<string> dagUrls;

    fp = fopen(manifestUrlName.c_str(), "r");
    if (fp == NULL) {
        return -1;
    }

    while ((read = getline(&line, &len, fp)) != -1) {
        dagUrls.push_back(line);
    }

    if (dagUrls.size() != 1) {
        die(-1, "there could only be one manifest DAG\n");
    }

    fclose(fp);
    if (line) {
        free(line);
    }

    // once we have read the manifest address, we send back the DAG
    // to the player, which will issue the actual manifest request
    // reply:
    // http://DAG.3.0.-.AD$c26124c5c3c3a964c03693c4bdfb625bb21faa1f.1.-.
    // HID$117a77f63181b5d6e63d5288d00cc09131462df5.2.-.
    // SID$15b7347ac78fc9aded44fbca0e6243698144fedd.3.-.
    // CID$7f521ad37897913c2f28cc21b79e098f9642073e
    // (one line)
    for (unsigned int i = 0; i < dagUrls.size(); i++) {
        strcat(reply, dagUrls[i].c_str());
        strcat(reply, " ");
    }
    reply[strlen(reply) - 1] = '\0';

    if (Xsend(proxy_sock, reply, strlen(reply), 0) < 0) {
        warn("unable to send reply to client\n");
        return -1;
    }

    return 1;
}

void *process_request (void *socketid) {
    int n, status = -1;
    int sock = *((int*)socketid);
    char message[XIA_MAXBUF];

    while (1) {

        memset(message, '\0', sizeof(message));

        if ((n = Xrecv(sock, message, XIA_MAXBUF, 0))  < 0) {
            warn("socket error while waiting for data, closing connection\n");
            break;
        }

        if (n != 0) {
            // if the request is a manifest request, handle it
            if (strncmp(message, XHTTP_INITIAL, strlen(XHTTP_INITIAL)) == 0) {
                status = handle_xhttp_request(sock, message);
            }

            if (status == -1) {
                warn("problem with handling request. Connection exit\n");
                break;
            }
        }
    }

    Xclose(sock);
    pthread_exit(NULL);
}

int register_receiver() {
    int sock;
    char sid_string[strlen("SID:") + XIA_SHA_DIGEST_STR_LEN];

    say ("\n%s (%s): started\n", TITLE, VERSION);

    // create a socket, and listen for incoming connections
    if ((sock = Xsocket(AF_XIA, SOCK_STREAM, 0)) < 0) {
        die(-1, "Unable to create the listening socket\n");
    }

    if (XmakeNewSID(sid_string, sizeof(sid_string))) {
        die(-1, "Unable to create a temporary SID");
    }

    struct addrinfo hints, *ai;
    bzero(&hints, sizeof(hints));
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_family = AF_XIA;

    if (Xgetaddrinfo(NULL, sid_string, &hints, &ai) != 0) {
        die(-1, "getaddrinfo failure!\n");
    }

    sockaddr_x *sa = (sockaddr_x*)ai->ai_addr;
    Graph g(sa);

    if (XregisterName(VIDEO_ORIGIN_SERVER_NAME, sa) < 0 ) {
        die(-1, "error registering name: %s\n", VIDEO_ORIGIN_SERVER_NAME);
    }

    if (Xbind(sock, (struct sockaddr*)sa, sizeof(sockaddr_x)) < 0) {
        Xclose(sock);
        die(-1, "Unable to bind to the dag: %s\n", g.dag_string().c_str());
    }

    say("listening on dag: %s\n", g.dag_string().c_str());

    Xlisten(sock, 5);

    Xfreeaddrinfo(ai);
    return sock;
}

void blocking_listener(int socketid) {
    while (1) {
        int acceptSock;

        say("Waiting for client to connect...\n");

        if ((acceptSock = Xaccept(socketid, NULL, NULL)) < 0) {
            warn("accept failed...\n");
            break;
        }

        say("connected to a new client\n");

        pthread_t client;
        pthread_create(&client, NULL, process_request, (void *)&acceptSock);
    }

    Xclose(socketid);
}

int main(int argc, char *argv[]) {
    get_config(argc, argv);

    int sock = register_receiver();
    blocking_listener(sock);
    return 0;
}